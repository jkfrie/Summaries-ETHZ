\section{Designing Secure Systems based on Trustworthy Computing and Attestation}

\paragraph{Trusted Computing Base (TCB): }
of a computer system is the set of all hardware, firmware, and/or software components that are critical to its security, in the sense that bugs or vulnerabilities occurring inside the TCB might jeopardize the security properties of the entire system.

\paragraph{Is my computer secure? current approaches: }
\begin{itemize}
    \item Program code in ROM: keep entire program in ROM. Is simple and noone can inject any additional software. But cannot update and can still use control-flow attack.
    \item Secure or Verified Boot: Only load code with valid signature. Only approved software can be loaded. Large OS almost certainly has a vulnerability, only one component needs to be compromised. SW or certificate revocation requires state (rollback to expired version attack)
    \item Virtual-machine-based Isolation: Isolate applications by executing them inside VMs. VMM smaller than OS assumed to be secure, smaller TCB, Isolation between applications. But VMM usually still large and part of TCB, complicates interaction between applications.
    \item Approach: Achieve high security for small subset of system.
\end{itemize}{}

\paragraph{Attestation for SW Integrity: }
\begin{itemize}
    \item Attestation enables veriier V to verify what software is executing on untrusted device.
\end{itemize}{}

\paragraph{General Approach: }
Three-step approach:
\begin{enumerate}
    \item Establis isolated execution environment
    \item Externally validate correctness of execution environment
    \item Autonomous launch and operation of execution environment
\end{enumerate}{}

\paragraph{Three core Mechanisms: }
\begin{itemize}

\item Isolated execution Hardware ensures partition
\item Remote attestation External validation
\item Sealed storage, Enable secure local execution and fetching of secret data after local root of trust is set up.
\end{itemize}{}

\paragraph{Adversary Model:}
\begin{itemize}
    \item Remote adversary launches network-based attacks (can compromise OS and applications and can control network communication)
    \item Local Hardware (local hardware assumed to be trusted)
    \item Realistic model, as remote attacks constitute majority of threats.
\end{itemize}{}

\subsection{Trusted Platform Module (TPM) Overview}

\paragraph{Core TPM Goals: }
\begin{itemize}
    \item[] Platform identity
    \item[] Remote attestation: Remote verifier can validate platform configuration (BIOS, OS, runnign apps)
    \item[] Sealed storage: Bind a secret to a specific platform configuration.
    \item[] Secure counter
    \item[] TPM is passive device that offers basic functionality to platform
    \item[] TPM will store measurements (hashes) that represent platform configuration in Platform Configuaration Registers PCR
    \item[] How to store long list of hashes securely sl.22 ff
\end{itemize}{}

\paragraph{Cryptographic Hash Function Properties: } 
\begin{itemize}
    \item one-wayness: given h(x) cannot find x' s.t. H(x') = H(x)
    \item Wek collision resistance: Given x, cannot find x' s.t. H(x) = H(x')
    \item Strong collision resistance: cannot find any x and x' s.t. H(x) = H(x')
\end{itemize}{}

\paragraph{Basic TPM Functions sl.26}

\subsection{Attested Boot}
TCG 1.1-Style Attestation
\begin{itemize}
    \item Approach: Measurement of all executed software and configuration files defines platform configuration.
    \item Desired property: Remote verifier can verify platform state by inspecting all measurements or hashes.
\end{itemize}{}

\paragraph{Integrity measurement Architecture (IMA)}

\paragraph{TCG 1.1 Use Cases: }
\begin{itemize}
    \item Securing corporate network access: corporation wants to ensure that all systems that connect to internal network have correct software.
    \item Secure online banking: User wants to ensure that her platform is malware- free before logging in to bank account. 
    \item Secure cloud computing: verify cloud environment before executing code.
\end{itemize}{}

\paragraph{Shortcomings of TCG 1.1-Style Attestation: }
\begin{itemize}
    \item Integrity measurements are done at load-time not at run-time.
    \item Coarse-grained, measures entire system
    \item No guarantee of execution.
\end{itemize}{}

\subsection{Dynamic Root of Trust}
\begin{itemize}
    \item Approach: Special CPU instruction creates isolated execution environment (IEE)
    \item Desired property: Remote verifier obtains strong assurance of code execution, achieve run-time attestation.
\end{itemize}{}

\paragraph{DRTM Computing Primitives}
\begin{itemize}
    \item Create Isolated Execution Environment (IEE)
    \item Remote verification/attestation of IEE
    \item Establish secure channel into IEE
    \item Externally verify that output O was generated by executing code S on input I prtected by IEE.
    \item Mehr infos slides 45. ff
\end{itemize}{}

\paragraph{Late Launch / DRTM}
\begin{itemize}
    \item Security properties similar to reboot, without a reboot. Removes many things from TCB.
    \item Allows execution of high-assurance software next to existing legacy OS, without the need to trust OS
\end{itemize}{}

\subsection{Discussion}
\paragraph{Secure Channel Establishement Protocols: }
\begin{itemize}
    \item Goal: Local Party wants to establish a secure channel to a IEE executing on a remote host. 
    \item Challenges: OS on remote host is untrusted, IEE needs to be invoked several times, as OS is handling network comm., OS keeps state for IEE.
    \item Assumptions: Local party knows correct public key of remote host, host hardware is not compromised, strong random numbers are available to IEE.
\end{itemize}{}

\paragraph{The cuckoo attack}

\subsection{Software-Only Root of Trust}
Achieve a Dynamic Root of Trust without HW support

\paragraph{Initial Setting:}
\begin{itemize}
    \item Untrusted device D, trusted verifier V
    \item V knows expected memory contents of D
    \item V wants to obtain proof of D's memory contents, obtain memory integrity
    \item D executes verification function VF
    \item Problem: malicious VF returns expected result.
\end{itemize}{}

\paragraph{Approaches:} 
\begin{itemize}
    \item Reflection: Fill entire memory randomly, get checksum of entire memory.
    \item Genuinity: verificatio function uses randomized memory access to cause unpredictable cache misses
    \item Alien vs. Quine: Implement a secure loader program.
    \item SWATT: Software based ATTestation for embedded devices. Verification function is a pseudorandom memory traverssal to compute memory checksum. Verifier times checksum computtaion and verifies checksum.
\end{itemize}{}

\subsubsection{SWATT}
\begin{itemize}
    \item Ned to make sure that there is not a faster way to compute checksum on the device.
    \item Need to make sure that response originates from the device.
    \item Checksum computed over entire device memory. Does not scale to large memory sizes.
    Solution: design checksum function that can check small memory areas (Memory area being checked includes checksum function), but introduces many
\end{itemize}{}

\paragraph{Attack on Partial Memory Verification: }

\paragraph{Challenges on x86 Platforms:}
\begin{itemize}
    \item Out of Order execution, cache and virtual memory.
    \item Complex instruction set and architecture how can we ensure code is optimal?
    \item DMA-based attacks from malicious peripherals
    \item interrupt-based attacks.
\end{itemize}{}

\subsubsection{Pioneer}
Goal: provide verifier with guarantee about what code execued on device.
\begin{enumerate}
    \item Verify code integrity through SW-only root-of-trust attestation.
    \item Set up untampered code execution environment
    \item Execute code
\end{enumerate}{}

\subsection{Potential Attacks}

\paragraph{Exceptions and Interrupts:}
\begin{itemize}
    \item Attacker installs malicious exception and interrupt handlers
    \item Attacker generates exception or interrupt during execution of Verification Function
    \item Solution: Replace interrupt and exception handlers, but when?
\end{itemize}{}

\subsubsection{Sensor Network Key Establishment}
Given nodes in a sensor network, how can any pair of nodes establish a shared secret without any prior authentic or secret information? In theory this is impossible because of active MitM attack.

\paragraph{ICE Key Establishment:}
\begin{itemize}
    \item leverage ICE to compute checksum faster than any other node, and use checksum as a short-lived shared secret.
\end{itemize}{}